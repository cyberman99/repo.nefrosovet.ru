// Package client provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package profile

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// AuthParams defines model for Auth_params.
type AuthParams struct {
	Login    string `json:"login"`
	Password string `json:"password"`
}

// Base defines model for Base.
type Base struct {
	Version string `json:"version"`
}

// Error defines model for Error.
type Error struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema
	Data interface{} `json:"data"`
}

// Error400 defines model for Error_400.
type Error400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error401 defines model for Error_401.
type Error401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error404 defines model for Error_404.
type Error404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// Error405 defines model for Error_405.
type Error405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  *[]interface{} `json:"errors,omitempty"`
	Message *string        `json:"message,omitempty"`
}

// Error500 defines model for Error_500.
type Error500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error
	// Embedded fields due to inline allOf schema
	Errors  interface{} `json:"errors"`
	Message string      `json:"message"`
}

// PasswordParams defines model for Password_params.
type PasswordParams struct {
	Password *string `json:"password,omitempty"`
}

// SettingsParams defines model for Settings_params.
type SettingsParams struct {
	N2FAChannelType *string `json:"2FAChannelType,omitempty"`
	Locale          *string `json:"locale,omitempty"`
}

// Success defines model for Success.
type Success struct {
	// Embedded struct due to allOf(#/components/schemas/Base)
	Base
	// Embedded fields due to inline allOf schema
	Errors  []interface{} `json:"errors"`
	Message string        `json:"message"`
}

// UserContact defines model for User_contact.
type UserContact struct {
	Value    *string `json:"value,omitempty"`
	Verified *bool   `json:"verified,omitempty"`
}

// UserParams defines model for User_params.
type UserParams struct {
	Email      *UserContact `json:"email,omitempty"`
	FirstName  *string      `json:"firstName,omitempty"`
	LastName   *string      `json:"lastName,omitempty"`
	MiddleName *string      `json:"middleName,omitempty"`
	Mobile     *UserContact `json:"mobile,omitempty"`
}

// UserParamsWithId defines model for User_params_with_id.
type UserParamsWithId struct {
	// Embedded fields due to inline allOf schema
	ID *string `json:"ID,omitempty"`
	// Embedded struct due to allOf(#/components/schemas/User_params)
	UserParams
	// Embedded fields due to inline allOf schema
}

// Email defines model for email.
type Email string

// Phone defines model for phone.
type Phone string

// UserID defines model for userID.
type UserID string

// Authorize200 defines model for Authorize_200.
type Authorize200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]struct {
		// Embedded fields due to inline allOf schema
		UserID string `json:"userID"`
	} `json:"data,omitempty"`
}

// Authorize400 defines model for Authorize_400.
type Authorize400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			Login    *string `json:"login,omitempty"`
			Password *string `json:"password,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// Base401 defines model for Base_401.
type Base401 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_401)
	Error401
}

// Base404 defines model for Base_404.
type Base404 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_404)
	Error404
}

// Base405 defines model for Base_405.
type Base405 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_405)
	Error405
}

// Base500 defines model for Base_500.
type Base500 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_500)
	Error500
}

// User200 defines model for User_200.
type User200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]UserParamsWithId `json:"data,omitempty"`
}

// User400 defines model for User_400.
type User400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			FirstName  *string `json:"firstName,omitempty"`
			LastName   *string `json:"lastName,omitempty"`
			MiddleName *string `json:"middleName,omitempty"`
			Password   *string `json:"password,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// UserSettings200 defines model for User_settings_200.
type UserSettings200 struct {
	// Embedded struct due to allOf(#/components/schemas/Success)
	Success
	// Embedded fields due to inline allOf schema
	Data *[]SettingsParams `json:"data,omitempty"`
}

// UserSettings400 defines model for User_settings_400.
type UserSettings400 struct {
	// Embedded struct due to allOf(#/components/schemas/Error_400)
	Error400
	// Embedded fields due to inline allOf schema
	// Embedded fields due to inline allOf schema
	Errors *struct {
		Validation *struct {
			N2FAChannelType *string `json:"2FAChannelType,omitempty"`
			Locale          *string `json:"locale,omitempty"`
		} `json:"validation,omitempty"`
	} `json:"errors,omitempty"`
}

// User defines model for User.
type User struct {
	// Embedded struct due to allOf(#/components/schemas/User_params)
	UserParams
	// Embedded struct due to allOf(#/components/schemas/Password_params)
	PasswordParams
}

// authorizeJSONBody defines parameters for Authorize.
type authorizeJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/Auth_params)
	AuthParams
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {

	// If the field is provided users will be filtered by phone
	Phone *Phone `json:"phone,omitempty"`

	// If the field is provided users will be filtered by email
	Email *Email `json:"email,omitempty"`
}

// patchUserSettingsJSONBody defines parameters for PatchUserSettings.
type patchUserSettingsJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/Settings_params)
	SettingsParams
}

// AuthorizeRequestBody defines body for Authorize for application/json ContentType.
type AuthorizeJSONRequestBody authorizeJSONBody

// PostUsersRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody User

// PatchUserRequestBody defines body for PatchUser for application/json ContentType.
type PatchUserJSONRequestBody User

// PatchUserSettingsRequestBody defines body for PatchUserSettings for application/json ContentType.
type PatchUserSettingsJSONRequestBody patchUserSettingsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Authorize request  with any body
	AuthorizeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	Authorize(ctx context.Context, body AuthorizeJSONRequestBody) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams) (*http.Response, error)

	// PostUsers request  with any body
	PostUsersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	PostUsers(ctx context.Context, body PostUsersJSONRequestBody) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userID UserID) (*http.Response, error)

	// PatchUser request  with any body
	PatchUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader) (*http.Response, error)

	PatchUser(ctx context.Context, userID UserID, body PatchUserJSONRequestBody) (*http.Response, error)

	// GetUserSettings request
	GetUserSettings(ctx context.Context, userID UserID) (*http.Response, error)

	// PatchUserSettings request  with any body
	PatchUserSettingsWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader) (*http.Response, error)

	PatchUserSettings(ctx context.Context, userID UserID, body PatchUserSettingsJSONRequestBody) (*http.Response, error)
}

func (c *Client) AuthorizeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAuthorizeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, body AuthorizeJSONRequestBody) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsers(ctx context.Context, body PostUsersJSONRequestBody) (*http.Response, error) {
	req, err := NewPostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userID UserID) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUser(ctx context.Context, userID UserID, body PatchUserJSONRequestBody) (*http.Response, error) {
	req, err := NewPatchUserRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSettings(ctx context.Context, userID UserID) (*http.Response, error) {
	req, err := NewGetUserSettingsRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserSettingsWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPatchUserSettingsRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserSettings(ctx context.Context, userID UserID, body PatchUserSettingsJSONRequestBody) (*http.Response, error) {
	req, err := NewPatchUserSettingsRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewAuthorizeRequest calls the generic Authorize builder with application/json body
func NewAuthorizeRequest(server string, body AuthorizeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthorizeRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthorizeRequestWithBody generates requests for Authorize with any type of body
func NewAuthorizeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/authorize"))

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users"))

	queryValues := queryUrl.Query()

	if params.Phone != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "phone", *params.Phone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Email != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "email", *params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersRequest calls the generic PostUsers builder with application/json body
func NewPostUsersRequest(server string, body PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUsersRequestWithBody generates requests for PostUsers with any type of body
func NewPostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users"))

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "userID", userID)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users/%s", pathParam0))

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserRequest calls the generic PatchUser builder with application/json body
func NewPatchUserRequest(server string, userID UserID, body PatchUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "userID", userID)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users/%s", pathParam0))

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetUserSettingsRequest generates requests for GetUserSettings
func NewGetUserSettingsRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "userID", userID)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users/%s/settings", pathParam0))

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserSettingsRequest calls the generic PatchUserSettings builder with application/json body
func NewPatchUserSettingsRequest(server string, userID UserID, body PatchUserSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserSettingsRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPatchUserSettingsRequestWithBody generates requests for PatchUserSettings with any type of body
func NewPatchUserSettingsRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "userID", userID)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl.Path = path.Join(queryUrl.Path, fmt.Sprintf("/users/%s/settings", pathParam0))

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		if !strings.HasSuffix(baseURL, "/") {
			baseURL += "/"
		}
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

type authorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]struct {
			// Embedded fields due to inline allOf schema
			UserID string `json:"userID"`
		} `json:"data,omitempty"`
	}
	JSON400 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_400)
		Error400
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		Errors *struct {
			Validation *struct {
				Login    *string `json:"login,omitempty"`
				Password *string `json:"password,omitempty"`
			} `json:"validation,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON401 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_401)
		Error401
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r authorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r authorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]UserParamsWithId `json:"data,omitempty"`
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r getUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type postUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]UserParamsWithId `json:"data,omitempty"`
	}
	JSON400 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_400)
		Error400
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		Errors *struct {
			Validation *struct {
				FirstName  *string `json:"firstName,omitempty"`
				LastName   *string `json:"lastName,omitempty"`
				MiddleName *string `json:"middleName,omitempty"`
				Password   *string `json:"password,omitempty"`
			} `json:"validation,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r postUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r postUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]UserParamsWithId `json:"data,omitempty"`
	}
	JSON404 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_404)
		Error404
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r getUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type patchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]UserParamsWithId `json:"data,omitempty"`
	}
	JSON400 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_400)
		Error400
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		Errors *struct {
			Validation *struct {
				FirstName  *string `json:"firstName,omitempty"`
				LastName   *string `json:"lastName,omitempty"`
				MiddleName *string `json:"middleName,omitempty"`
				Password   *string `json:"password,omitempty"`
			} `json:"validation,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON404 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_404)
		Error404
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r patchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r patchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]SettingsParams `json:"data,omitempty"`
	}
	JSON404 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_404)
		Error404
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r getUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type patchUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Success)
		Success
		// Embedded fields due to inline allOf schema
		Data *[]SettingsParams `json:"data,omitempty"`
	}
	JSON400 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_400)
		Error400
		// Embedded fields due to inline allOf schema
		// Embedded fields due to inline allOf schema
		Errors *struct {
			Validation *struct {
				N2FAChannelType *string `json:"2FAChannelType,omitempty"`
				Locale          *string `json:"locale,omitempty"`
			} `json:"validation,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON404 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_404)
		Error404
	}
	JSON405 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_405)
		Error405
	}
	JSON500 *struct {
		// Embedded struct due to allOf(#/components/schemas/Error_500)
		Error500
	}
}

// Status returns HTTPResponse.Status
func (r patchUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r patchUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthorizeWithBodyWithResponse request with arbitrary body returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*authorizeResponse, error) {
	rsp, err := c.AuthorizeWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseauthorizeResponse(rsp)
}

func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, body AuthorizeJSONRequestBody) (*authorizeResponse, error) {
	rsp, err := c.Authorize(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseauthorizeResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams) (*getUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParsegetUsersResponse(rsp)
}

// PostUsersWithBodyWithResponse request with arbitrary body returning *PostUsersResponse
func (c *ClientWithResponses) PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*postUsersResponse, error) {
	rsp, err := c.PostUsersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsepostUsersResponse(rsp)
}

func (c *ClientWithResponses) PostUsersWithResponse(ctx context.Context, body PostUsersJSONRequestBody) (*postUsersResponse, error) {
	rsp, err := c.PostUsers(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsepostUsersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userID UserID) (*getUserResponse, error) {
	rsp, err := c.GetUser(ctx, userID)
	if err != nil {
		return nil, err
	}
	return ParsegetUserResponse(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserResponse
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader) (*patchUserResponse, error) {
	rsp, err := c.PatchUserWithBody(ctx, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsepatchUserResponse(rsp)
}

func (c *ClientWithResponses) PatchUserWithResponse(ctx context.Context, userID UserID, body PatchUserJSONRequestBody) (*patchUserResponse, error) {
	rsp, err := c.PatchUser(ctx, userID, body)
	if err != nil {
		return nil, err
	}
	return ParsepatchUserResponse(rsp)
}

// GetUserSettingsWithResponse request returning *GetUserSettingsResponse
func (c *ClientWithResponses) GetUserSettingsWithResponse(ctx context.Context, userID UserID) (*getUserSettingsResponse, error) {
	rsp, err := c.GetUserSettings(ctx, userID)
	if err != nil {
		return nil, err
	}
	return ParsegetUserSettingsResponse(rsp)
}

// PatchUserSettingsWithBodyWithResponse request with arbitrary body returning *PatchUserSettingsResponse
func (c *ClientWithResponses) PatchUserSettingsWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader) (*patchUserSettingsResponse, error) {
	rsp, err := c.PatchUserSettingsWithBody(ctx, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsepatchUserSettingsResponse(rsp)
}

func (c *ClientWithResponses) PatchUserSettingsWithResponse(ctx context.Context, userID UserID, body PatchUserSettingsJSONRequestBody) (*patchUserSettingsResponse, error) {
	rsp, err := c.PatchUserSettings(ctx, userID, body)
	if err != nil {
		return nil, err
	}
	return ParsepatchUserSettingsResponse(rsp)
}

// ParseauthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseauthorizeResponse(rsp *http.Response) (*authorizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &authorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]struct {
				// Embedded fields due to inline allOf schema
				UserID string `json:"userID"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		response.JSON400 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_400)
			Error400
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			Errors *struct {
				Validation *struct {
					Login    *string `json:"login,omitempty"`
					Password *string `json:"password,omitempty"`
				} `json:"validation,omitempty"`
			} `json:"errors,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON400); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		response.JSON401 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_401)
			Error401
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON401); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsegetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParsegetUsersResponse(rsp *http.Response) (*getUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]UserParamsWithId `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsepostUsersResponse parses an HTTP response from a PostUsersWithResponse call
func ParsepostUsersResponse(rsp *http.Response) (*postUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &postUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]UserParamsWithId `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		response.JSON400 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_400)
			Error400
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			Errors *struct {
				Validation *struct {
					FirstName  *string `json:"firstName,omitempty"`
					LastName   *string `json:"lastName,omitempty"`
					MiddleName *string `json:"middleName,omitempty"`
					Password   *string `json:"password,omitempty"`
				} `json:"validation,omitempty"`
			} `json:"errors,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON400); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsegetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParsegetUserResponse(rsp *http.Response) (*getUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]UserParamsWithId `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		response.JSON404 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_404)
			Error404
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON404); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsepatchUserResponse parses an HTTP response from a PatchUserWithResponse call
func ParsepatchUserResponse(rsp *http.Response) (*patchUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &patchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]UserParamsWithId `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		response.JSON400 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_400)
			Error400
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			Errors *struct {
				Validation *struct {
					FirstName  *string `json:"firstName,omitempty"`
					LastName   *string `json:"lastName,omitempty"`
					MiddleName *string `json:"middleName,omitempty"`
					Password   *string `json:"password,omitempty"`
				} `json:"validation,omitempty"`
			} `json:"errors,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON400); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		response.JSON404 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_404)
			Error404
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON404); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsegetUserSettingsResponse parses an HTTP response from a GetUserSettingsWithResponse call
func ParsegetUserSettingsResponse(rsp *http.Response) (*getUserSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]SettingsParams `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		response.JSON404 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_404)
			Error404
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON404); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsepatchUserSettingsResponse parses an HTTP response from a PatchUserSettingsWithResponse call
func ParsepatchUserSettingsResponse(rsp *http.Response) (*patchUserSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &patchUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Success)
			Success
			// Embedded fields due to inline allOf schema
			Data *[]SettingsParams `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		response.JSON400 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_400)
			Error400
			// Embedded fields due to inline allOf schema
			// Embedded fields due to inline allOf schema
			Errors *struct {
				Validation *struct {
					N2FAChannelType *string `json:"2FAChannelType,omitempty"`
					Locale          *string `json:"locale,omitempty"`
				} `json:"validation,omitempty"`
			} `json:"errors,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON400); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		response.JSON404 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_404)
			Error404
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON404); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		response.JSON405 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_405)
			Error405
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON405); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		response.JSON500 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Error_500)
			Error500
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON500); err != nil {
			return nil, err
		}

	}

	return response, nil
}
