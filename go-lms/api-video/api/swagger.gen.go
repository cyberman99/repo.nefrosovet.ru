// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/errorboi/kin-openapi-playground/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ApiDataStringObject defines model for api_data_string_object.
type ApiDataStringObject struct {
	Data *string `json:"data,omitempty"`
}

// ApiEmptyDataObject defines model for api_empty_data_object.
type ApiEmptyDataObject struct {
	Data *[]interface{} `json:"data,omitempty"`
}

// ApiError defines model for api_error.
type ApiError struct {
	// Embedded fields due to inline allOf schema
	Code  *int           `json:"code,omitempty"`
	Data  *[]interface{} `json:"data,omitempty"`
	Error *bool          `json:"error,omitempty"`
}

// ApiMessage defines model for api_message.
type ApiMessage struct {
	// Embedded fields due to inline allOf schema
	Code    *int    `json:"code,omitempty"`
	Error   *bool   `json:"error,omitempty"`
	Message *string `json:"message,omitempty"`
}

// ApiMessageArrayStringObject defines model for api_message_array_string_object.
type ApiMessageArrayStringObject struct {
	Message *[]string `json:"message,omitempty"`
}

// ApiMessageStringObject defines model for api_message_string_object.
type ApiMessageStringObject struct {
	Message *string `json:"message,omitempty"`
}

// ApiStreamIndexObject defines model for api_stream_index_object.
type ApiStreamIndexObject struct {
	Data *[]StreamData `json:"data,omitempty"`
}

// ApiStreamStoreObject defines model for api_stream_store_object.
type ApiStreamStoreObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/stream_create_data)
		StreamCreateData
	} `json:"data,omitempty"`
}

// ApiUserIndexErrorsObject defines model for api_user_index_errors_object.
type ApiUserIndexErrorsObject struct {
	Message *struct {
		// Embedded struct due to allOf(#/components/schemas/user_validation_data)
		UserValidationData
	} `json:"message,omitempty"`
}

// ApiUserIndexObject defines model for api_user_index_object.
type ApiUserIndexObject struct {
	Data *[]UsersData `json:"data,omitempty"`
}

// ApiUserShowObject defines model for api_user_show_object.
type ApiUserShowObject struct {
	Data *UserData `json:"data,omitempty"`
}

// ApiUserStoreObject defines model for api_user_store_object.
type ApiUserStoreObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/user_create_data)
		UserCreateData
	} `json:"data,omitempty"`
}

// ApiWebinarIndexObject defines model for api_webinar_index_object.
type ApiWebinarIndexObject struct {
	Data *[]WebinarJsonData `json:"data,omitempty"`
}

// ApiWebinarMosaicDataObject defines model for api_webinar_mosaic_data_object.
type ApiWebinarMosaicDataObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_data_with_template)
		WebinarMosaicDataWithTemplate
	} `json:"data,omitempty"`
}

// ApiWebinarMosaicDestroyObject defines model for api_webinar_mosaic_destroy_object.
type ApiWebinarMosaicDestroyObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_data)
		WebinarMosaicData
	} `json:"data,omitempty"`
}

// ApiWebinarMosaicIndexObject defines model for api_webinar_mosaic_index_object.
type ApiWebinarMosaicIndexObject struct {
	Data *[]WebinarMosaicDataWithTemplate `json:"data,omitempty"`
}

// ApiWebinarMosaicSlotIndexObject defines model for api_webinar_mosaic_slot_index_object.
type ApiWebinarMosaicSlotIndexObject struct {
	Data *[]SlotTypeData `json:"data,omitempty"`
}

// ApiWebinarMosaicSlotUpdateObject defines model for api_webinar_mosaic_slot_update_object.
type ApiWebinarMosaicSlotUpdateObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_slot_update_data)
		WebinarMosaicSlotUpdateData
	} `json:"data,omitempty"`
}

// ApiWebinarMosaicUserDestroyObject defines model for api_webinar_mosaic_user_destroy_object.
type ApiWebinarMosaicUserDestroyObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_user_destroy_data)
		WebinarMosaicUserDestroyData
	} `json:"data,omitempty"`
}

// ApiWebinarMosaicUserIndexObject defines model for api_webinar_mosaic_user_index_object.
type ApiWebinarMosaicUserIndexObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_user_index_data)
		WebinarMosaicUserIndexData
	} `json:"data,omitempty"`
}

// ApiWebinarShowObject defines model for api_webinar_show_object.
type ApiWebinarShowObject struct {
	Data *WebinarJsonData `json:"data,omitempty"`
}

// ApiWebinarStoreObject defines model for api_webinar_store_object.
type ApiWebinarStoreObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_create_data)
		WebinarCreateData
	} `json:"data,omitempty"`
}

// ApiWebinarUserDestroyObject defines model for api_webinar_user_destroy_object.
type ApiWebinarUserDestroyObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_user_destroy_data)
		WebinarUserDestroyData
	} `json:"data,omitempty"`
}

// ApiWebinarUserIndexObject defines model for api_webinar_user_index_object.
type ApiWebinarUserIndexObject struct {
	Data *[]WebinarUserJsonData `json:"data,omitempty"`
}

// ApiWebinarUserMosaicStoreObject defines model for api_webinar_user_mosaic_store_object.
type ApiWebinarUserMosaicStoreObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_user_mosaic_store_data)
		WebinarUserMosaicStoreData
	} `json:"data,omitempty"`
}

// ApiWebinarUserShowUpdateObject defines model for api_webinar_user_show_update_object.
type ApiWebinarUserShowUpdateObject struct {
	Data *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_user_json_data)
		WebinarUserJsonData
	} `json:"data,omitempty"`
}

// ApiWebinarUserUpdateErrorsObject defines model for api_webinar_user_update_errors_object.
type ApiWebinarUserUpdateErrorsObject struct {
	Message *struct {
		// Embedded struct due to allOf(#/components/schemas/webinar_user_validation_data)
		WebinarUserValidationData
	} `json:"message,omitempty"`
}

// SlotTypeData defines model for slot_type_data.
type SlotTypeData string

// StreamCreateData defines model for stream_create_data.
type StreamCreateData struct {
	// Embedded fields due to inline allOf schema
	FileId   int `json:"file_id"`
	StreamId int `json:"stream_id"`
}

// StreamData defines model for stream_data.
type StreamData struct {
	// Embedded fields due to inline allOf schema
	Id     int    `json:"id"`
	Status string `json:"status"`
}

// UserCreateData defines model for user_create_data.
type UserCreateData struct {
	// Embedded fields due to inline allOf schema
	UserId int `json:"userId"`
}

// UserData defines model for user_data.
type UserData struct {
	// Embedded fields due to inline allOf schema
	Password string `json:"password"`
	Username string `json:"username"`
}

// UserValidationData defines model for user_validation_data.
type UserValidationData struct {
	// Embedded fields due to inline allOf schema
	Required *string `json:"required,omitempty"`
	SipValid *string `json:"sip_valid,omitempty"`
}

// UsersData defines model for users_data.
type UsersData struct {
	// Embedded fields due to inline allOf schema
	Sip    string `json:"sip"`
	UserId int    `json:"user_id"`
}

// WebinarCreateData defines model for webinar_create_data.
type WebinarCreateData struct {
	// Embedded fields due to inline allOf schema
	DID    string `json:"DID"`
	Id     int    `json:"id"`
	Status string `json:"status"`
}

// WebinarJsonData defines model for webinar_json_data.
type WebinarJsonData string

// WebinarMosaicData defines model for webinar_mosaic_data.
type WebinarMosaicData struct {
	// Embedded fields due to inline allOf schema
	MosaicId int `json:"mosaicId"`
}

// WebinarMosaicDataWithTemplate defines model for webinar_mosaic_data_with_template.
type WebinarMosaicDataWithTemplate struct {
	// Embedded struct due to allOf(#/components/schemas/webinar_mosaic_data)
	WebinarMosaicData
	// Embedded fields due to inline allOf schema
	Template string `json:"template"`
}

// WebinarMosaicSlotUpdateData defines model for webinar_mosaic_slot_update_data.
type WebinarMosaicSlotUpdateData struct {
	// Embedded fields due to inline allOf schema
	SlotId int    `json:"slotId"`
	Type   string `json:"type"`
}

// WebinarMosaicUserDestroyData defines model for webinar_mosaic_user_destroy_data.
type WebinarMosaicUserDestroyData struct {
	// Embedded fields due to inline allOf schema
	MosaicId  int `json:"mosaicId"`
	UserId    int `json:"userId"`
	WebinarId int `json:"webinarId"`
}

// WebinarMosaicUserIndexData defines model for webinar_mosaic_user_index_data.
type WebinarMosaicUserIndexData struct {
	// Embedded fields due to inline allOf schema
	Users      []WebinarUserJsonData `json:"users"`
	UsersCount int                   `json:"usersCount"`
}

// WebinarUserDestroyData defines model for webinar_user_destroy_data.
type WebinarUserDestroyData struct {
	// Embedded fields due to inline allOf schema
	Status       string `json:"status"`
	SubscriberId int    `json:"subscriberId"`
	UserId       int    `json:"userId"`
	Webinar      int    `json:"webinar"`
}

// WebinarUserJsonData defines model for webinar_user_json_data.
type WebinarUserJsonData string

// WebinarUserMosaicStoreData defines model for webinar_user_mosaic_store_data.
type WebinarUserMosaicStoreData struct {
	// Embedded fields due to inline allOf schema
	MosaicId  int    `json:"mosaicId"`
	State     string `json:"state"`
	WebinarId int    `json:"webinarId"`
}

// WebinarUserValidationData defines model for webinar_user_validation_data.
type WebinarUserValidationData struct {
	// Embedded fields due to inline allOf schema
	Numeric         *string `json:"numeric,omitempty"`
	RequiredWithout *string `json:"required_without,omitempty"`
}

// Action defines model for action.
type Action string

// Conf defines model for conf.
type Conf string

// ConfId defines model for confId.
type ConfId string

// Event defines model for event.
type Event string

// FileId defines model for fileId.
type FileId int

// Id defines model for id.
type Id int

// Label defines model for label.
type Label string

// Mic defines model for mic.
type Mic int

// MosaicID defines model for mosaicID.
type MosaicID int

// MosaicId defines model for mosaicId.
type MosaicId int

// Page defines model for page.
type Page int

// Part defines model for part.
type Part string

// Sip defines model for sip.
type Sip string

// SlotID defines model for slotID.
type SlotID int

// Sound defines model for sound.
type Sound int

// State defines model for state.
type State string

// StreamID defines model for streamID.
type StreamID int

// StreamId defines model for streamId.
type StreamId int

// TemplateId defines model for templateId.
type TemplateId int

// Type defines model for type.
type Type string

// UserID defines model for userID.
type UserID int

// UserId defines model for userId.
type UserId int

// WebinarID defines model for webinarID.
type WebinarID int

// BaseArrayResponse400 defines model for base_array_response_400.
type BaseArrayResponse400 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_array_string_object)
	ApiMessageArrayStringObject
}

// BaseResponse400 defines model for base_response_400.
type BaseResponse400 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// BaseResponse401 defines model for base_response_401.
type BaseResponse401 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// BaseResponse404 defines model for base_response_404.
type BaseResponse404 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// BaseResponse405 defines model for base_response_405.
type BaseResponse405 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// BaseResponse500 defines model for base_response_500.
type BaseResponse500 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// MedoozeResponse200 defines model for medooze_response_200.
type MedoozeResponse200 struct {
	// Embedded fields due to inline allOf schema
}

// MedoozeResponse500 defines model for medooze_response_500.
type MedoozeResponse500 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_message_string_object)
	ApiMessageStringObject
}

// RootResponse200 defines model for root_response_200.
type RootResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_data_string_object)
	ApiDataStringObject
}

// StreamCreateResponse200 defines model for stream_create_response_200.
type StreamCreateResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_stream_store_object)
	ApiStreamStoreObject
}

// StreamIndexResponse200 defines model for stream_index_response_200.
type StreamIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_stream_index_object)
	ApiStreamIndexObject
}

// StreamUpdateResponse200 defines model for stream_update_response_200.
type StreamUpdateResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_empty_data_object)
	ApiEmptyDataObject
}

// UserIndexResponse200 defines model for user_index_response_200.
type UserIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_user_index_object)
	ApiUserIndexObject
}

// UserShowResponse200 defines model for user_show_response_200.
type UserShowResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_user_show_object)
	ApiUserShowObject
}

// UserStoreResponse200 defines model for user_store_response_200.
type UserStoreResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_user_store_object)
	ApiUserStoreObject
}

// UserStoreResponse400 defines model for user_store_response_400.
type UserStoreResponse400 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_user_index_errors_object)
	ApiUserIndexErrorsObject
}

// WebinarCreateResponse200 defines model for webinar_create_response_200.
type WebinarCreateResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_store_object)
	ApiWebinarStoreObject
}

// WebinarDestroyResponse200 defines model for webinar_destroy_response_200.
type WebinarDestroyResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_show_object)
	ApiWebinarShowObject
}

// WebinarIndexResponse200 defines model for webinar_index_response_200.
type WebinarIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_index_object)
	ApiWebinarIndexObject
}

// WebinarMosaicDataResponse200 defines model for webinar_mosaic_data_response_200.
type WebinarMosaicDataResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_data_object)
	ApiWebinarMosaicDataObject
}

// WebinarMosaicDestroyResponse200 defines model for webinar_mosaic_destroy_response_200.
type WebinarMosaicDestroyResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_destroy_object)
	ApiWebinarMosaicDestroyObject
}

// WebinarMosaicIndexResponse200 defines model for webinar_mosaic_index_response_200.
type WebinarMosaicIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_index_object)
	ApiWebinarMosaicIndexObject
}

// WebinarMosaicSlotIndexResponse200 defines model for webinar_mosaic_slot_index_response_200.
type WebinarMosaicSlotIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_slot_index_object)
	ApiWebinarMosaicSlotIndexObject
}

// WebinarMosaicSlotUpdateResponse200 defines model for webinar_mosaic_slot_update_response_200.
type WebinarMosaicSlotUpdateResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_slot_update_object)
	ApiWebinarMosaicSlotUpdateObject
}

// WebinarMosaicUserDestroyResponse200 defines model for webinar_mosaic_user_destroy_response_200.
type WebinarMosaicUserDestroyResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_user_destroy_object)
	ApiWebinarMosaicUserDestroyObject
}

// WebinarMosaicUserIndexResponse200 defines model for webinar_mosaic_user_index_response_200.
type WebinarMosaicUserIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_mosaic_user_index_object)
	ApiWebinarMosaicUserIndexObject
}

// WebinarShowResponse200 defines model for webinar_show_response_200.
type WebinarShowResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_show_object)
	ApiWebinarShowObject
}

// WebinarUserDestroyResponse200 defines model for webinar_user_destroy_response_200.
type WebinarUserDestroyResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_user_destroy_object)
	ApiWebinarUserDestroyObject
}

// WebinarUserIndexResponse200 defines model for webinar_user_index_response_200.
type WebinarUserIndexResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_user_index_object)
	ApiWebinarUserIndexObject
}

// WebinarUserMosaicStoreResponse200 defines model for webinar_user_mosaic_store_response_200.
type WebinarUserMosaicStoreResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_user_mosaic_store_object)
	ApiWebinarUserMosaicStoreObject
}

// WebinarUserShowUpdateResponse200 defines model for webinar_user_show_update_response_200.
type WebinarUserShowUpdateResponse200 struct {
	// Embedded struct due to allOf(#/components/schemas/api_message)
	ApiMessage
	// Embedded struct due to allOf(#/components/schemas/api_webinar_user_show_update_object)
	ApiWebinarUserShowUpdateObject
}

// WebinarUserUpdateResponse400 defines model for webinar_user_update_response_400.
type WebinarUserUpdateResponse400 struct {
	// Embedded struct due to allOf(#/components/schemas/api_error)
	ApiError
	// Embedded struct due to allOf(#/components/schemas/api_webinar_user_update_errors_object)
	ApiWebinarUserUpdateErrorsObject
}

// EventHandlerParams defines parameters for EventHandler.
type EventHandlerParams struct {
	Conf Conf `json:"conf"`

	// Тип события
	Event  Event   `json:"event"`
	State  *State  `json:"state,omitempty"`
	Part   *Part   `json:"part,omitempty"`
	ConfId *ConfId `json:"confId,omitempty"`
}

// UserStoreParams defines parameters for UserStore.
type UserStoreParams struct {
	Sip *Sip `json:"sip,omitempty"`
}

// WebinarMosaicStoreParams defines parameters for WebinarMosaicStore.
type WebinarMosaicStoreParams struct {
	TemplateId TemplateId `json:"templateId"`
}

// WebinarMosaicUpdateParams defines parameters for WebinarMosaicUpdate.
type WebinarMosaicUpdateParams struct {
	TemplateId TemplateId `json:"templateId"`
}

// WebinarMosaicSlotUpdateParams defines parameters for WebinarMosaicSlotUpdate.
type WebinarMosaicSlotUpdateParams struct {
	Type     Type      `json:"type"`
	UserId   *UserId   `json:"userId,omitempty"`
	StreamId *StreamId `json:"streamId,omitempty"`
}

// WebinarMosaicUserStoreParams defines parameters for WebinarMosaicUserStore.
type WebinarMosaicUserStoreParams struct {
	UserId *UserId `json:"userId,omitempty"`
}

// WebinarStreamStoreParams defines parameters for WebinarStreamStore.
type WebinarStreamStoreParams struct {
	FileId FileId `json:"fileId"`
}

// WebinarStreamUpdateParams defines parameters for WebinarStreamUpdate.
type WebinarStreamUpdateParams struct {
	Action Action `json:"action"`
	Page   *Page  `json:"page,omitempty"`
}

// WebinarUserStoreParams defines parameters for WebinarUserStore.
type WebinarUserStoreParams struct {
	UserId *UserId `json:"userId,omitempty"`
	Label  *Label  `json:"label,omitempty"`
}

// WebinarUserUpdateParams defines parameters for WebinarUserUpdate.
type WebinarUserUpdateParams struct {
	Mic   Mic   `json:"mic"`
	Sound Sound `json:"sound"`
}

// WebinarUserMosaicStoreParams defines parameters for WebinarUserMosaicStore.
type WebinarUserMosaicStoreParams struct {
	MosaicId MosaicId `json:"mosaicId"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Обработка событий// (POST /api/medooze)
	EventHandler(ctx echo.Context, params EventHandlerParams) error
	// Получение списка юзеров// (GET /api/v1/user)
	UserIndex(ctx echo.Context) error
	// Создание юзера// (POST /api/v1/user)
	UserStore(ctx echo.Context, params UserStoreParams) error
	// Данные юзера// (GET /api/v1/user/{userID})
	UserShow(ctx echo.Context, userID UserID) error
	// Получение списка вебинаров// (GET /api/v1/webinar)
	WebinarIndex(ctx echo.Context) error
	// Создание вебинара// (POST /api/v1/webinar)
	WebinarStore(ctx echo.Context) error
	// Заверешение вебинара// (DELETE /api/v1/webinar/{id})
	WebinarDestroy(ctx echo.Context, id Id) error
	// Получение вебинара// (GET /api/v1/webinar/{id})
	WebinarShow(ctx echo.Context, id Id) error
	// Получение списка мозаик вебинара// (GET /api/v1/webinar/{webinarID}/mosaic/)
	WebinarMosaicIndex(ctx echo.Context, webinarID WebinarID) error
	// Создание мозаики вебинара// (POST /api/v1/webinar/{webinarID}/mosaic/)
	WebinarMosaicStore(ctx echo.Context, webinarID WebinarID, params WebinarMosaicStoreParams) error
	// Удаление мозаики вебинара// (DELETE /api/v1/webinar/{webinarID}/mosaic/{mosaicID})
	WebinarMosaicDestroy(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID) error
	// Получение мозаики вебинара// (GET /api/v1/webinar/{webinarID}/mosaic/{mosaicID})
	WebinarMosaicShow(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID) error
	// Изменение мозаики вебинара// (PATCH /api/v1/webinar/{webinarID}/mosaic/{mosaicID})
	WebinarMosaicUpdate(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID, params WebinarMosaicUpdateParams) error
	// Получение списка слотов мозаики вебинара// (GET /api/v1/webinar/{webinarID}/mosaic/{mosaicID}/slot)
	WebinarMosaicSlotIndex(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID) error
	// Изменение слота мозаики вебинара// (PATCH /api/v1/webinar/{webinarID}/mosaic/{mosaicID}/slot/{slotID})
	WebinarMosaicSlotUpdate(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID, slotID SlotID, params WebinarMosaicSlotUpdateParams) error
	// Получение списка юзеров мозаики вебинара// (GET /api/v1/webinar/{webinarID}/mosaic/{mosaicID}/user)
	WebinarMosaicUserIndex(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID) error
	// Получение списка мозаик вебинара// (POST /api/v1/webinar/{webinarID}/mosaic/{mosaicID}/user)
	WebinarMosaicUserStore(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID, params WebinarMosaicUserStoreParams) error
	// Получение юзера мозаики вебинара// (DELETE /api/v1/webinar/{webinarID}/mosaic/{mosaicID}/user/{userID})
	WebinarMosaicUserShow(ctx echo.Context, webinarID WebinarID, mosaicID MosaicID, userID UserID) error
	// Получение списка потоков// (GET /api/v1/webinar/{webinarID}/stream)
	WebinarStreamIndex(ctx echo.Context, webinarID WebinarID) error
	// Создание потока// (POST /api/v1/webinar/{webinarID}/stream)
	WebinarStreamStore(ctx echo.Context, webinarID WebinarID, params WebinarStreamStoreParams) error
	// Удаление потока// (DELETE /api/v1/webinar/{webinarID}/stream/{streamID})
	WebinarStreamDestroy(ctx echo.Context, webinarID WebinarID, streamID StreamID) error
	// Изменение данных потока// (PATCH /api/v1/webinar/{webinarID}/stream/{streamID})
	WebinarStreamUpdate(ctx echo.Context, webinarID WebinarID, streamID StreamID, params WebinarStreamUpdateParams) error
	// Получение списка юзеров вебинара// (GET /api/v1/webinar/{webinarID}/user)
	WebinarUserIndex(ctx echo.Context, webinarID WebinarID) error
	// Создание юзера вебинара// (POST /api/v1/webinar/{webinarID}/user)
	WebinarUserStore(ctx echo.Context, webinarID WebinarID, params WebinarUserStoreParams) error
	// Удаление юзера вебинара// (DELETE /api/v1/webinar/{webinarID}/user/{userID})
	WebinarUserDestroy(ctx echo.Context, webinarID WebinarID, userID UserID) error
	// Получение юзера вебинара// (GET /api/v1/webinar/{webinarID}/user/{userID})
	WebinarUserShow(ctx echo.Context, webinarID WebinarID, userID UserID) error
	// Изменение юзера вебинара// (PATCH /api/v1/webinar/{webinarID}/user/{userID})
	WebinarUserUpdate(ctx echo.Context, webinarID WebinarID, userID UserID, params WebinarUserUpdateParams) error
	// Создание мозаики юзера вебинара// (POST /api/v1/webinar/{webinarID}/user/{userID}/mosaic)
	WebinarUserMosaicStore(ctx echo.Context, webinarID WebinarID, userID UserID, params WebinarUserMosaicStoreParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// EventHandler converts echo context to params.
func (w *ServerInterfaceWrapper) EventHandler(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params EventHandlerParams
	// ------------- Required query parameter "conf" -------------
	if paramValue := ctx.QueryParam("conf"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument conf is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "conf", ctx.QueryParams(), &params.Conf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter conf: %s", err))
	}

	// ------------- Required query parameter "event" -------------
	if paramValue := ctx.QueryParam("event"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument event is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "event", ctx.QueryParams(), &params.Event)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event: %s", err))
	}

	// ------------- Optional query parameter "state" -------------
	if paramValue := ctx.QueryParam("state"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "part" -------------
	if paramValue := ctx.QueryParam("part"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "part", ctx.QueryParams(), &params.Part)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter part: %s", err))
	}

	// ------------- Optional query parameter "confId" -------------
	if paramValue := ctx.QueryParam("confId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "confId", ctx.QueryParams(), &params.ConfId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter confId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EventHandler(ctx, params)
	return err
}

// UserIndex converts echo context to params.
func (w *ServerInterfaceWrapper) UserIndex(ctx echo.Context) error {
	var err error

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserIndex(ctx)
	return err
}

// UserStore converts echo context to params.
func (w *ServerInterfaceWrapper) UserStore(ctx echo.Context) error {
	var err error

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserStoreParams
	// ------------- Optional query parameter "sip" -------------
	if paramValue := ctx.QueryParam("sip"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sip", ctx.QueryParams(), &params.Sip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sip: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserStore(ctx, params)
	return err
}

// UserShow converts echo context to params.
func (w *ServerInterfaceWrapper) UserShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserShow(ctx, userID)
	return err
}

// WebinarIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarIndex(ctx echo.Context) error {
	var err error

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarIndex(ctx)
	return err
}

// WebinarStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarStore(ctx echo.Context) error {
	var err error

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarStore(ctx)
	return err
}

// WebinarDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarDestroy(ctx, id)
	return err
}

// WebinarShow converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarShow(ctx, id)
	return err
}

// WebinarMosaicIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicIndex(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicIndex(ctx, webinarID)
	return err
}

// WebinarMosaicStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicStore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarMosaicStoreParams
	// ------------- Required query parameter "templateId" -------------
	if paramValue := ctx.QueryParam("templateId"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument templateId is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "templateId", ctx.QueryParams(), &params.TemplateId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter templateId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicStore(ctx, webinarID, params)
	return err
}

// WebinarMosaicDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicDestroy(ctx, webinarID, mosaicID)
	return err
}

// WebinarMosaicShow converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicShow(ctx, webinarID, mosaicID)
	return err
}

// WebinarMosaicUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarMosaicUpdateParams
	// ------------- Required query parameter "templateId" -------------
	if paramValue := ctx.QueryParam("templateId"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument templateId is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "templateId", ctx.QueryParams(), &params.TemplateId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter templateId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicUpdate(ctx, webinarID, mosaicID, params)
	return err
}

// WebinarMosaicSlotIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicSlotIndex(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicSlotIndex(ctx, webinarID, mosaicID)
	return err
}

// WebinarMosaicSlotUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicSlotUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	// ------------- Path parameter "slotID" -------------
	var slotID SlotID

	err = runtime.BindStyledParameter("simple", false, "slotID", ctx.Param("slotID"), &slotID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slotID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarMosaicSlotUpdateParams
	// ------------- Required query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument type is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "userId" -------------
	if paramValue := ctx.QueryParam("userId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// ------------- Optional query parameter "streamId" -------------
	if paramValue := ctx.QueryParam("streamId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "streamId", ctx.QueryParams(), &params.StreamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicSlotUpdate(ctx, webinarID, mosaicID, slotID, params)
	return err
}

// WebinarMosaicUserIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicUserIndex(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicUserIndex(ctx, webinarID, mosaicID)
	return err
}

// WebinarMosaicUserStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicUserStore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarMosaicUserStoreParams
	// ------------- Optional query parameter "userId" -------------
	if paramValue := ctx.QueryParam("userId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicUserStore(ctx, webinarID, mosaicID, params)
	return err
}

// WebinarMosaicUserShow converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarMosaicUserShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "mosaicID" -------------
	var mosaicID MosaicID

	err = runtime.BindStyledParameter("simple", false, "mosaicID", ctx.Param("mosaicID"), &mosaicID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarMosaicUserShow(ctx, webinarID, mosaicID, userID)
	return err
}

// WebinarStreamIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarStreamIndex(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarStreamIndex(ctx, webinarID)
	return err
}

// WebinarStreamStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarStreamStore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarStreamStoreParams
	// ------------- Required query parameter "fileId" -------------
	if paramValue := ctx.QueryParam("fileId"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument fileId is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "fileId", ctx.QueryParams(), &params.FileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fileId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarStreamStore(ctx, webinarID, params)
	return err
}

// WebinarStreamDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarStreamDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "streamID" -------------
	var streamID StreamID

	err = runtime.BindStyledParameter("simple", false, "streamID", ctx.Param("streamID"), &streamID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarStreamDestroy(ctx, webinarID, streamID)
	return err
}

// WebinarStreamUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarStreamUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "streamID" -------------
	var streamID StreamID

	err = runtime.BindStyledParameter("simple", false, "streamID", ctx.Param("streamID"), &streamID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarStreamUpdateParams
	// ------------- Required query parameter "action" -------------
	if paramValue := ctx.QueryParam("action"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument action is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "action", ctx.QueryParams(), &params.Action)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action: %s", err))
	}

	// ------------- Optional query parameter "page" -------------
	if paramValue := ctx.QueryParam("page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarStreamUpdate(ctx, webinarID, streamID, params)
	return err
}

// WebinarUserIndex converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserIndex(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserIndex(ctx, webinarID)
	return err
}

// WebinarUserStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserStore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarUserStoreParams
	// ------------- Optional query parameter "userId" -------------
	if paramValue := ctx.QueryParam("userId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// ------------- Optional query parameter "label" -------------
	if paramValue := ctx.QueryParam("label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "label", ctx.QueryParams(), &params.Label)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserStore(ctx, webinarID, params)
	return err
}

// WebinarUserDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserDestroy(ctx, webinarID, userID)
	return err
}

// WebinarUserShow converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserShow(ctx, webinarID, userID)
	return err
}

// WebinarUserUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarUserUpdateParams
	// ------------- Required query parameter "mic" -------------
	if paramValue := ctx.QueryParam("mic"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument mic is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "mic", ctx.QueryParams(), &params.Mic)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mic: %s", err))
	}

	// ------------- Required query parameter "sound" -------------
	if paramValue := ctx.QueryParam("sound"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sound is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sound", ctx.QueryParams(), &params.Sound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sound: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserUpdate(ctx, webinarID, userID, params)
	return err
}

// WebinarUserMosaicStore converts echo context to params.
func (w *ServerInterfaceWrapper) WebinarUserMosaicStore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "webinarID" -------------
	var webinarID WebinarID

	err = runtime.BindStyledParameter("simple", false, "webinarID", ctx.Param("webinarID"), &webinarID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter webinarID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameter("simple", false, "userID", ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set("AuthToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params WebinarUserMosaicStoreParams
	// ------------- Required query parameter "mosaicId" -------------
	if paramValue := ctx.QueryParam("mosaicId"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument mosaicId is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "mosaicId", ctx.QueryParams(), &params.MosaicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mosaicId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WebinarUserMosaicStore(ctx, webinarID, userID, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/api/medooze", wrapper.EventHandler)
	router.GET("/api/v1/user", wrapper.UserIndex)
	router.POST("/api/v1/user", wrapper.UserStore)
	router.GET("/api/v1/user/:userID", wrapper.UserShow)
	router.GET("/api/v1/webinar", wrapper.WebinarIndex)
	router.POST("/api/v1/webinar", wrapper.WebinarStore)
	router.DELETE("/api/v1/webinar/:id", wrapper.WebinarDestroy)
	router.GET("/api/v1/webinar/:id", wrapper.WebinarShow)
	router.GET("/api/v1/webinar/:webinarID/mosaic/", wrapper.WebinarMosaicIndex)
	router.POST("/api/v1/webinar/:webinarID/mosaic/", wrapper.WebinarMosaicStore)
	router.DELETE("/api/v1/webinar/:webinarID/mosaic/:mosaicID", wrapper.WebinarMosaicDestroy)
	router.GET("/api/v1/webinar/:webinarID/mosaic/:mosaicID", wrapper.WebinarMosaicShow)
	router.PATCH("/api/v1/webinar/:webinarID/mosaic/:mosaicID", wrapper.WebinarMosaicUpdate)
	router.GET("/api/v1/webinar/:webinarID/mosaic/:mosaicID/slot", wrapper.WebinarMosaicSlotIndex)
	router.PATCH("/api/v1/webinar/:webinarID/mosaic/:mosaicID/slot/:slotID", wrapper.WebinarMosaicSlotUpdate)
	router.GET("/api/v1/webinar/:webinarID/mosaic/:mosaicID/user", wrapper.WebinarMosaicUserIndex)
	router.POST("/api/v1/webinar/:webinarID/mosaic/:mosaicID/user", wrapper.WebinarMosaicUserStore)
	router.DELETE("/api/v1/webinar/:webinarID/mosaic/:mosaicID/user/:userID", wrapper.WebinarMosaicUserShow)
	router.GET("/api/v1/webinar/:webinarID/stream", wrapper.WebinarStreamIndex)
	router.POST("/api/v1/webinar/:webinarID/stream", wrapper.WebinarStreamStore)
	router.DELETE("/api/v1/webinar/:webinarID/stream/:streamID", wrapper.WebinarStreamDestroy)
	router.PATCH("/api/v1/webinar/:webinarID/stream/:streamID", wrapper.WebinarStreamUpdate)
	router.GET("/api/v1/webinar/:webinarID/user", wrapper.WebinarUserIndex)
	router.POST("/api/v1/webinar/:webinarID/user", wrapper.WebinarUserStore)
	router.DELETE("/api/v1/webinar/:webinarID/user/:userID", wrapper.WebinarUserDestroy)
	router.GET("/api/v1/webinar/:webinarID/user/:userID", wrapper.WebinarUserShow)
	router.PATCH("/api/v1/webinar/:webinarID/user/:userID", wrapper.WebinarUserUpdate)
	router.POST("/api/v1/webinar/:webinarID/user/:userID/mosaic", wrapper.WebinarUserMosaicStore)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"c3ugv9v/bwAAAP//v9JU033AAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

