// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"repo.nefrosovet.ru/go-lms/api-video/ent/accountkey"
	"repo.nefrosovet.ru/go-lms/api-video/ent/predicate"
	"repo.nefrosovet.ru/go-lms/api-video/ent/user"
	"repo.nefrosovet.ru/go-lms/api-video/ent/useraccount"
)

// UserAccountUpdate is the builder for updating UserAccount entities.
type UserAccountUpdate struct {
	config
	username            *string
	password            *string
	remember_token      *string
	clearremember_token bool
	active              *int16
	addactive           *int16
	event_channel       *string
	clearevent_channel  bool
	did_prefix          *string
	use_kamalio         *int16
	adduse_kamalio      *int16
	user                map[int]struct{}
	accountkeys         map[int]struct{}
	clearedUser         bool
	removedAccountkeys  map[int]struct{}
	predicates          []predicate.UserAccount
}

// Where adds a new predicate for the builder.
func (uau *UserAccountUpdate) Where(ps ...predicate.UserAccount) *UserAccountUpdate {
	uau.predicates = append(uau.predicates, ps...)
	return uau
}

// SetUsername sets the username field.
func (uau *UserAccountUpdate) SetUsername(s string) *UserAccountUpdate {
	uau.username = &s
	return uau
}

// SetPassword sets the password field.
func (uau *UserAccountUpdate) SetPassword(s string) *UserAccountUpdate {
	uau.password = &s
	return uau
}

// SetRememberToken sets the remember_token field.
func (uau *UserAccountUpdate) SetRememberToken(s string) *UserAccountUpdate {
	uau.remember_token = &s
	return uau
}

// SetNillableRememberToken sets the remember_token field if the given value is not nil.
func (uau *UserAccountUpdate) SetNillableRememberToken(s *string) *UserAccountUpdate {
	if s != nil {
		uau.SetRememberToken(*s)
	}
	return uau
}

// ClearRememberToken clears the value of remember_token.
func (uau *UserAccountUpdate) ClearRememberToken() *UserAccountUpdate {
	uau.remember_token = nil
	uau.clearremember_token = true
	return uau
}

// SetActive sets the active field.
func (uau *UserAccountUpdate) SetActive(i int16) *UserAccountUpdate {
	uau.active = &i
	uau.addactive = nil
	return uau
}

// SetNillableActive sets the active field if the given value is not nil.
func (uau *UserAccountUpdate) SetNillableActive(i *int16) *UserAccountUpdate {
	if i != nil {
		uau.SetActive(*i)
	}
	return uau
}

// AddActive adds i to active.
func (uau *UserAccountUpdate) AddActive(i int16) *UserAccountUpdate {
	if uau.addactive == nil {
		uau.addactive = &i
	} else {
		*uau.addactive += i
	}
	return uau
}

// SetEventChannel sets the event_channel field.
func (uau *UserAccountUpdate) SetEventChannel(s string) *UserAccountUpdate {
	uau.event_channel = &s
	return uau
}

// SetNillableEventChannel sets the event_channel field if the given value is not nil.
func (uau *UserAccountUpdate) SetNillableEventChannel(s *string) *UserAccountUpdate {
	if s != nil {
		uau.SetEventChannel(*s)
	}
	return uau
}

// ClearEventChannel clears the value of event_channel.
func (uau *UserAccountUpdate) ClearEventChannel() *UserAccountUpdate {
	uau.event_channel = nil
	uau.clearevent_channel = true
	return uau
}

// SetDidPrefix sets the did_prefix field.
func (uau *UserAccountUpdate) SetDidPrefix(s string) *UserAccountUpdate {
	uau.did_prefix = &s
	return uau
}

// SetNillableDidPrefix sets the did_prefix field if the given value is not nil.
func (uau *UserAccountUpdate) SetNillableDidPrefix(s *string) *UserAccountUpdate {
	if s != nil {
		uau.SetDidPrefix(*s)
	}
	return uau
}

// SetUseKamalio sets the use_kamalio field.
func (uau *UserAccountUpdate) SetUseKamalio(i int16) *UserAccountUpdate {
	uau.use_kamalio = &i
	uau.adduse_kamalio = nil
	return uau
}

// SetNillableUseKamalio sets the use_kamalio field if the given value is not nil.
func (uau *UserAccountUpdate) SetNillableUseKamalio(i *int16) *UserAccountUpdate {
	if i != nil {
		uau.SetUseKamalio(*i)
	}
	return uau
}

// AddUseKamalio adds i to use_kamalio.
func (uau *UserAccountUpdate) AddUseKamalio(i int16) *UserAccountUpdate {
	if uau.adduse_kamalio == nil {
		uau.adduse_kamalio = &i
	} else {
		*uau.adduse_kamalio += i
	}
	return uau
}

// SetUserID sets the user edge to User by id.
func (uau *UserAccountUpdate) SetUserID(id int) *UserAccountUpdate {
	if uau.user == nil {
		uau.user = make(map[int]struct{})
	}
	uau.user[id] = struct{}{}
	return uau
}

// SetUser sets the user edge to User.
func (uau *UserAccountUpdate) SetUser(u *User) *UserAccountUpdate {
	return uau.SetUserID(u.ID)
}

// AddAccountkeyIDs adds the accountkeys edge to AccountKey by ids.
func (uau *UserAccountUpdate) AddAccountkeyIDs(ids ...int) *UserAccountUpdate {
	if uau.accountkeys == nil {
		uau.accountkeys = make(map[int]struct{})
	}
	for i := range ids {
		uau.accountkeys[ids[i]] = struct{}{}
	}
	return uau
}

// AddAccountkeys adds the accountkeys edges to AccountKey.
func (uau *UserAccountUpdate) AddAccountkeys(a ...*AccountKey) *UserAccountUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uau.AddAccountkeyIDs(ids...)
}

// ClearUser clears the user edge to User.
func (uau *UserAccountUpdate) ClearUser() *UserAccountUpdate {
	uau.clearedUser = true
	return uau
}

// RemoveAccountkeyIDs removes the accountkeys edge to AccountKey by ids.
func (uau *UserAccountUpdate) RemoveAccountkeyIDs(ids ...int) *UserAccountUpdate {
	if uau.removedAccountkeys == nil {
		uau.removedAccountkeys = make(map[int]struct{})
	}
	for i := range ids {
		uau.removedAccountkeys[ids[i]] = struct{}{}
	}
	return uau
}

// RemoveAccountkeys removes accountkeys edges to AccountKey.
func (uau *UserAccountUpdate) RemoveAccountkeys(a ...*AccountKey) *UserAccountUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uau.RemoveAccountkeyIDs(ids...)
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (uau *UserAccountUpdate) Save(ctx context.Context) (int, error) {
	if uau.username != nil {
		if err := useraccount.UsernameValidator(*uau.username); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"username\": %v", err)
		}
	}
	if uau.password != nil {
		if err := useraccount.PasswordValidator(*uau.password); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"password\": %v", err)
		}
	}
	if uau.remember_token != nil {
		if err := useraccount.RememberTokenValidator(*uau.remember_token); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"remember_token\": %v", err)
		}
	}
	if uau.event_channel != nil {
		if err := useraccount.EventChannelValidator(*uau.event_channel); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"event_channel\": %v", err)
		}
	}
	if uau.did_prefix != nil {
		if err := useraccount.DidPrefixValidator(*uau.did_prefix); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"did_prefix\": %v", err)
		}
	}
	if len(uau.user) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"user\"")
	}
	if uau.clearedUser && uau.user == nil {
		return 0, errors.New("ent: clearing a unique edge \"user\"")
	}
	return uau.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (uau *UserAccountUpdate) SaveX(ctx context.Context) int {
	affected, err := uau.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (uau *UserAccountUpdate) Exec(ctx context.Context) error {
	_, err := uau.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uau *UserAccountUpdate) ExecX(ctx context.Context) {
	if err := uau.Exec(ctx); err != nil {
		panic(err)
	}
}

func (uau *UserAccountUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   useraccount.Table,
			Columns: useraccount.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: useraccount.FieldID,
			},
		},
	}
	if ps := uau.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := uau.username; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldUsername,
		})
	}
	if value := uau.password; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldPassword,
		})
	}
	if value := uau.remember_token; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldRememberToken,
		})
	}
	if uau.clearremember_token {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: useraccount.FieldRememberToken,
		})
	}
	if value := uau.active; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldActive,
		})
	}
	if value := uau.addactive; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldActive,
		})
	}
	if value := uau.event_channel; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldEventChannel,
		})
	}
	if uau.clearevent_channel {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: useraccount.FieldEventChannel,
		})
	}
	if value := uau.did_prefix; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldDidPrefix,
		})
	}
	if value := uau.use_kamalio; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldUseKamalio,
		})
	}
	if value := uau.adduse_kamalio; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldUseKamalio,
		})
	}
	if uau.clearedUser {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   useraccount.UserTable,
			Columns: []string{useraccount.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uau.user; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   useraccount.UserTable,
			Columns: []string{useraccount.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if nodes := uau.removedAccountkeys; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   useraccount.AccountkeysTable,
			Columns: []string{useraccount.AccountkeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: accountkey.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uau.accountkeys; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   useraccount.AccountkeysTable,
			Columns: []string{useraccount.AccountkeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: accountkey.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, uau.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// UserAccountUpdateOne is the builder for updating a single UserAccount entity.
type UserAccountUpdateOne struct {
	config
	id                  int
	username            *string
	password            *string
	remember_token      *string
	clearremember_token bool
	active              *int16
	addactive           *int16
	event_channel       *string
	clearevent_channel  bool
	did_prefix          *string
	use_kamalio         *int16
	adduse_kamalio      *int16
	user                map[int]struct{}
	accountkeys         map[int]struct{}
	clearedUser         bool
	removedAccountkeys  map[int]struct{}
}

// SetUsername sets the username field.
func (uauo *UserAccountUpdateOne) SetUsername(s string) *UserAccountUpdateOne {
	uauo.username = &s
	return uauo
}

// SetPassword sets the password field.
func (uauo *UserAccountUpdateOne) SetPassword(s string) *UserAccountUpdateOne {
	uauo.password = &s
	return uauo
}

// SetRememberToken sets the remember_token field.
func (uauo *UserAccountUpdateOne) SetRememberToken(s string) *UserAccountUpdateOne {
	uauo.remember_token = &s
	return uauo
}

// SetNillableRememberToken sets the remember_token field if the given value is not nil.
func (uauo *UserAccountUpdateOne) SetNillableRememberToken(s *string) *UserAccountUpdateOne {
	if s != nil {
		uauo.SetRememberToken(*s)
	}
	return uauo
}

// ClearRememberToken clears the value of remember_token.
func (uauo *UserAccountUpdateOne) ClearRememberToken() *UserAccountUpdateOne {
	uauo.remember_token = nil
	uauo.clearremember_token = true
	return uauo
}

// SetActive sets the active field.
func (uauo *UserAccountUpdateOne) SetActive(i int16) *UserAccountUpdateOne {
	uauo.active = &i
	uauo.addactive = nil
	return uauo
}

// SetNillableActive sets the active field if the given value is not nil.
func (uauo *UserAccountUpdateOne) SetNillableActive(i *int16) *UserAccountUpdateOne {
	if i != nil {
		uauo.SetActive(*i)
	}
	return uauo
}

// AddActive adds i to active.
func (uauo *UserAccountUpdateOne) AddActive(i int16) *UserAccountUpdateOne {
	if uauo.addactive == nil {
		uauo.addactive = &i
	} else {
		*uauo.addactive += i
	}
	return uauo
}

// SetEventChannel sets the event_channel field.
func (uauo *UserAccountUpdateOne) SetEventChannel(s string) *UserAccountUpdateOne {
	uauo.event_channel = &s
	return uauo
}

// SetNillableEventChannel sets the event_channel field if the given value is not nil.
func (uauo *UserAccountUpdateOne) SetNillableEventChannel(s *string) *UserAccountUpdateOne {
	if s != nil {
		uauo.SetEventChannel(*s)
	}
	return uauo
}

// ClearEventChannel clears the value of event_channel.
func (uauo *UserAccountUpdateOne) ClearEventChannel() *UserAccountUpdateOne {
	uauo.event_channel = nil
	uauo.clearevent_channel = true
	return uauo
}

// SetDidPrefix sets the did_prefix field.
func (uauo *UserAccountUpdateOne) SetDidPrefix(s string) *UserAccountUpdateOne {
	uauo.did_prefix = &s
	return uauo
}

// SetNillableDidPrefix sets the did_prefix field if the given value is not nil.
func (uauo *UserAccountUpdateOne) SetNillableDidPrefix(s *string) *UserAccountUpdateOne {
	if s != nil {
		uauo.SetDidPrefix(*s)
	}
	return uauo
}

// SetUseKamalio sets the use_kamalio field.
func (uauo *UserAccountUpdateOne) SetUseKamalio(i int16) *UserAccountUpdateOne {
	uauo.use_kamalio = &i
	uauo.adduse_kamalio = nil
	return uauo
}

// SetNillableUseKamalio sets the use_kamalio field if the given value is not nil.
func (uauo *UserAccountUpdateOne) SetNillableUseKamalio(i *int16) *UserAccountUpdateOne {
	if i != nil {
		uauo.SetUseKamalio(*i)
	}
	return uauo
}

// AddUseKamalio adds i to use_kamalio.
func (uauo *UserAccountUpdateOne) AddUseKamalio(i int16) *UserAccountUpdateOne {
	if uauo.adduse_kamalio == nil {
		uauo.adduse_kamalio = &i
	} else {
		*uauo.adduse_kamalio += i
	}
	return uauo
}

// SetUserID sets the user edge to User by id.
func (uauo *UserAccountUpdateOne) SetUserID(id int) *UserAccountUpdateOne {
	if uauo.user == nil {
		uauo.user = make(map[int]struct{})
	}
	uauo.user[id] = struct{}{}
	return uauo
}

// SetUser sets the user edge to User.
func (uauo *UserAccountUpdateOne) SetUser(u *User) *UserAccountUpdateOne {
	return uauo.SetUserID(u.ID)
}

// AddAccountkeyIDs adds the accountkeys edge to AccountKey by ids.
func (uauo *UserAccountUpdateOne) AddAccountkeyIDs(ids ...int) *UserAccountUpdateOne {
	if uauo.accountkeys == nil {
		uauo.accountkeys = make(map[int]struct{})
	}
	for i := range ids {
		uauo.accountkeys[ids[i]] = struct{}{}
	}
	return uauo
}

// AddAccountkeys adds the accountkeys edges to AccountKey.
func (uauo *UserAccountUpdateOne) AddAccountkeys(a ...*AccountKey) *UserAccountUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uauo.AddAccountkeyIDs(ids...)
}

// ClearUser clears the user edge to User.
func (uauo *UserAccountUpdateOne) ClearUser() *UserAccountUpdateOne {
	uauo.clearedUser = true
	return uauo
}

// RemoveAccountkeyIDs removes the accountkeys edge to AccountKey by ids.
func (uauo *UserAccountUpdateOne) RemoveAccountkeyIDs(ids ...int) *UserAccountUpdateOne {
	if uauo.removedAccountkeys == nil {
		uauo.removedAccountkeys = make(map[int]struct{})
	}
	for i := range ids {
		uauo.removedAccountkeys[ids[i]] = struct{}{}
	}
	return uauo
}

// RemoveAccountkeys removes accountkeys edges to AccountKey.
func (uauo *UserAccountUpdateOne) RemoveAccountkeys(a ...*AccountKey) *UserAccountUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uauo.RemoveAccountkeyIDs(ids...)
}

// Save executes the query and returns the updated entity.
func (uauo *UserAccountUpdateOne) Save(ctx context.Context) (*UserAccount, error) {
	if uauo.username != nil {
		if err := useraccount.UsernameValidator(*uauo.username); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"username\": %v", err)
		}
	}
	if uauo.password != nil {
		if err := useraccount.PasswordValidator(*uauo.password); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"password\": %v", err)
		}
	}
	if uauo.remember_token != nil {
		if err := useraccount.RememberTokenValidator(*uauo.remember_token); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"remember_token\": %v", err)
		}
	}
	if uauo.event_channel != nil {
		if err := useraccount.EventChannelValidator(*uauo.event_channel); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"event_channel\": %v", err)
		}
	}
	if uauo.did_prefix != nil {
		if err := useraccount.DidPrefixValidator(*uauo.did_prefix); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"did_prefix\": %v", err)
		}
	}
	if len(uauo.user) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"user\"")
	}
	if uauo.clearedUser && uauo.user == nil {
		return nil, errors.New("ent: clearing a unique edge \"user\"")
	}
	return uauo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (uauo *UserAccountUpdateOne) SaveX(ctx context.Context) *UserAccount {
	ua, err := uauo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return ua
}

// Exec executes the query on the entity.
func (uauo *UserAccountUpdateOne) Exec(ctx context.Context) error {
	_, err := uauo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uauo *UserAccountUpdateOne) ExecX(ctx context.Context) {
	if err := uauo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (uauo *UserAccountUpdateOne) sqlSave(ctx context.Context) (ua *UserAccount, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   useraccount.Table,
			Columns: useraccount.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  uauo.id,
				Type:   field.TypeInt,
				Column: useraccount.FieldID,
			},
		},
	}
	if value := uauo.username; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldUsername,
		})
	}
	if value := uauo.password; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldPassword,
		})
	}
	if value := uauo.remember_token; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldRememberToken,
		})
	}
	if uauo.clearremember_token {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: useraccount.FieldRememberToken,
		})
	}
	if value := uauo.active; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldActive,
		})
	}
	if value := uauo.addactive; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldActive,
		})
	}
	if value := uauo.event_channel; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldEventChannel,
		})
	}
	if uauo.clearevent_channel {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: useraccount.FieldEventChannel,
		})
	}
	if value := uauo.did_prefix; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: useraccount.FieldDidPrefix,
		})
	}
	if value := uauo.use_kamalio; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldUseKamalio,
		})
	}
	if value := uauo.adduse_kamalio; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt16,
			Value:  *value,
			Column: useraccount.FieldUseKamalio,
		})
	}
	if uauo.clearedUser {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   useraccount.UserTable,
			Columns: []string{useraccount.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uauo.user; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   useraccount.UserTable,
			Columns: []string{useraccount.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if nodes := uauo.removedAccountkeys; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   useraccount.AccountkeysTable,
			Columns: []string{useraccount.AccountkeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: accountkey.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uauo.accountkeys; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   useraccount.AccountkeysTable,
			Columns: []string{useraccount.AccountkeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: accountkey.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	ua = &UserAccount{config: uauo.config}
	_spec.Assign = ua.assignValues
	_spec.ScanValues = ua.scanValues()
	if err = sqlgraph.UpdateNode(ctx, uauo.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return ua, nil
}
